TinyShell
-----------------------------------------------------------------------
Ένα μικρό Unix shell γραμμένο σε C για Linux.

Το TinyShell, είναι ένα απλά Unix like shell σχεδιασμένο για να συμπεριφέρεται όπως ένα σύγχρονο command interpreter. Χρησιμοποιέι POSIX system calls (fork, execve,waitpid,access), για την κατανόηση του τρόπου λειτουργίας των Unix shells.


Χαρακτηριστικά:
-----------------------------------------------------------------------
1. Εμφανίζει prompt (tiny-shell>>)
2. Αναλύει τα ορίσματα
3. Εντοπίζει εκτελέσιμα στο PATH
4. Τα εκτελέι με fork και execve
5. Αναφέρει τους κωδικούς εξόδου
6. Μπορεί να εκτελεί προγράμματα όπως ls, cat ή echo, και τερματίζει    ομαλά είτε με EOF είτε με την εντολή exit (για τώρα).
7.Μπορεί να εκτελέσει εντολές ανακτεύθυνσης εξόδου με τον τελεστή >,<
8.Υποστηρίζει τη σύνδεση δύο εντολών μέσω του αγωγού | χρησιμοποιόντας την συνάρτηση pipe()
9.Υποστιρίζει εντολές που συνδιάζουν εντολές αγωγού με εντολές ανακατεύθυνσης
Προαπαιτούμενα:
-----------------------------------------------------------------------
1. Λειτουργικό σύστμα Linux για την χρήση των fork execve 
2. Compiler gcc ή clang
3. Εγκατεστημένα βασικά Unix εγαλεία (ls,cat,echo) αφού δεν έγινε η υλοποίση αυτών αλλά απλά καλούνται από το PATH

Για Build:
-----------------------------------------------------------------------
gcc -Wall -Wextra -o tinyshell tiny_shell.c

Για Εκτέλεση
-----------------------------------------------------------------------
./tinyshell

Περιγραφή Κώδικα:
-----------------------------------------------------------------------
int main(void) : 
-----------------------------------------------------------------------
Η συνάρτηση εκκίνησης του προγράμματος όπου το μόνο που κάνει είναι να καλέσει την tiny_shell_loop() για να ξεκινήσει τον βρόχο εντολών.

void tiny_shell_loop(void) :
-----------------------------------------------------------------------
Εμφανίζει το prompt tiny-shell>>
και καλεί την συνάρτηση input_detection() για να εντοπίσει οποιαδήποτε είσοδο.
Τερματίζει για είσοδο exit ή Ctrl+D


int iput_detection(void) :
-----------------------------------------------------------------------
Διαβάζει stdin (μέχρι 1024 χαρακκτήρες)
Διαχωρίζει την είσοδο σε tokens με βάση τα κενά με την χρήση του strtok

Επιστρέφει:
1-> το shell συνεχίζει να λειτουργεί
0-> δόθηκε exit 
-1-> ανίχνευση EOF

int command_processing(char *argv[], int argc) :
-----------------------------------------------------------------------
ελέγχει αν η εντολή που δώθηκε είναι η exit ή help 
και μετά αν είναι μια από τις ls,exho,cat και την εκτελεί με την συνάρτηση execute_external_command
Σε κάθε άλλη περίπτωση τυπώνει μήνυμα "command not found"

Επιστρέφει:
1-> το shell συνεχίζει να λειτουργεί
0-> εντολή exit

int execute_external_command(char *argv[], int argc) :
-----------------------------------------------------------------------
Ορίσματα:
char *argv[] -> πίνακας ορισμάτων πχ {"ls","-l",NULL}
int argc -> αριθμός ορισμάτων

Εντοπίζει το εκτελέσιμο μέσω της find_path()
δημιουργεί νέα διεργασία με fork() και το παιδί εκτελέι την εντολή μέσω execve() (είναι σημαντικό το fork διότι το execve έχει ως αποτέλεσμα να τερματίζει το proccess επομένως αφού δεν θες να τερματίσει το πρόγραμμα πρέπει να τερματίσει το child και όχι ο parent)
Τέλος περιμένει με waitpid() και εμφανίζει τον κωδικό εξόδου 

Επιστρέφει:
1-> μετά την ολοκλήρωση της εντολής
Ή μηνύματα σφάλματος

char* find_in_path(const char *command):
-----------------------------------------------------------------------
Ορίσματα:
const char *command -> το όνομα της εντολής

Αν η εντολή περιέχει / ελέγχει αν είναι εκτελέσιμη με access()
αλλιώς ψάχνει κάθε κατάλογο στο PATH για να βρει το εκτελέσιμο
Επιστρέφει το πλήρες μονοπάτι του εκτελέσιμου ή NULL αν δεν βρεθεί

Επιστρέφει:
char* -> Συμβολοσειρά με το πλήρες path της εντολής, το οποίο πρέπει να ελευθερωθεί με free() μετά την χρήση της εντολής
NUll -> αν δεν βρει το path

int redirect(char *infile, char *outfile, int append)
-----------------------------------------------------------------------
Ορίσματα:
char *infile->είναι το όνομα του αρχείου από το οποίο θα διαβάσει
char *outfile->είναι το όνομα του αρχείου στο οποίο θα γράψουμε την έξοδο
int append-> παίρνει τιμές 0 αν το αρχείο θα το κάνει truncate δηλαδή θα σβήσει τα πάντα και θα γράφει από την αρχή. 1 αν αθ κάνει append δηλαδή να προσθέσει νέα δεδομένα στο τέλος του αρχείου.

Επιστρέφει:
1 αν όλα πάνε καλά
-1 αν έχω κάποιο error στην εντολή open()

int parse_redirection(char *argv[], int *argc,char **infile, char **outfile, int *append)
-----------------------------------------------------------------------
Ορίσματα:
char *argv[]->πίνακας ορισμάτων πχ {"cat","<","input.txt",">","output.txt",NULL}
int *argc->αριθμός ορισμάτων
char **infile->δείκτης σε string όπου θα αποθηκευτεί το όνομα του αρχείου εισόδου
char **outfile->δείκτης σε string όπου θα αποθηκευτεί το όνομα του αρχείου εξόδου
int *append->flag για το αν η έξοδος θα γίνει append (1) ή truncate (0)

Σαρώνει το argv για <,>,>> Τα αφαιρεί κάνοντας τα NULL και ενημερώνει τα *infile,*outfile,*append

Επιστρέφει:
0 αν όλα πήγαν καλά
1 σε περίπτωση συντακτικού λάθους

int command_count(char *argv[], int argc)
-----------------------------------------------------------------------
Ορίσματα:
char *argv[]->πίνακας ορισμάτων πχ {"cat","<","input.txt",">","output.txt",NULL}
int *argc->αριθμός ορισμάτων

Μετράει πόσες εντολές υπάρχουν στον πίνακα argv, ξέροντας πως οι εντολές διαχωρίζονται με NULL

Επιστρέφει:
Τον αριθμό των εντολών στον πίνακα argv

int pipe_detection(char *argv[], int argc)
-----------------------------------------------------------------------
Ορίσματα:
char *argv[]->πίνακας ορισμάτων πχ {"cat","<","input.txt",">","output.txt",NULL}
int *argc->αριθμός ορισμάτων

Σαρώνει τον πίνακα για το σύμβολο |. Αν το βρει το αντικαθιστά με NULL για να ξεχωρίσει τον argv σε ξεχωριστά τμήματα στα οποία υπάρχουν οι εντολές. Τέλος καλεί την command_count για να υπολογίσει τον αριθμό των εντολών.

Επιστρέφει:
Τον αριθμό των εντολών που βρέθηκαν
-1 σε περίπτωση συντακτικού λάθους

int piping(char *argv[], int pipe_count)
-----------------------------------------------------------------------
Ορίσμτα:
char *argv[]->πίνακας ορισμάτων πχ {"cat","<","input.txt",">","output.txt",NULL} όπου τα | έχουν αντικατασταθεί από NULL
int pipe_count-> αριθμός εντολών που θα εκτελεστούν

Δημιουργεί pipe_count-1 pipes για να συνδέσει την έξοδο κάθε εντολής με την είσοδο της επόμενης.
Κάνει fork() για κάθε εντολή, όπου κάθε παιδί συνέει τα stdin/stdout με τα κατάλληλα pipes.Μετά κλείνει όλα τα μη απαραίτητα File Descriptors και καλεί την parse_redirection για να κάνει redirect input/output αν υπάρχει. Τέλος εκτελεί την εντολή με execvp
Μετά ο parent κλείνει όλα τα pipe ends και περιμένει με waitpid() τα παιδιά.

Επιστρέφει:
0 αν όλα πήγαν καλά
-1 σε περίπτωση σφάλματος(pipe,fork ή execvp)

