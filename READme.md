TinyShell

Ένα μικρό Unix shell γραμμένο σε C για Linux.

Το TinyShell, είναι ένα απλά Unix like shell σχεδιασμένο για να συμπεριφέρεται όπως ένα σύγχρονο command interpreter. Χρησιμοποιέι POSIX system calls (fork, execve,waitpid,access), για την κατανόηση του τρόπου λειτουργίας των Unix shells.


Χαρακτηριστικά:

1. Εμφανίζει prompt (tiny-shell>>)
2. Αναλύει τα ορίσματα
3. Εντοπίζει εκτελέσιμα στο PATH
4. Τα εκτελέι με fork και execve
5. Αναφέρει τους κωδικούς εξόδου
6. Μπορεί να εκτελεί προγράμματα όπως ls, cat ή echo, και τερματίζει    ομαλά είτε με EOF είτε με την εντολή exit (για τώρα).

Προαπαιτούμενα:
1. Λειτουργικό σύστμα Linux για την χρήση των fork execve 
2. Compiler gcc ή clang
3. Εγκατεστημένα βασικά Unix εγαλεία (ls,cat,echo) αφού δεν έγινε η υλοποίση αυτών αλλά απλά καλούνται από το PATH

Για Build:
gcc -Wall -Wextra -o tinyshell tinyshell.c

Για Εκτέλεση
./tinyshell

Περιγραφή Κώδικα:
-----------------------------------------------------------------------
int main(void) : 
Η συνάρτηση εκκίνησης του προγράμματος όπου το μόνο που κάνει είναι να καλέσει την tiny_shell_loop() για να ξεκινήσει τον βρόχο εντολών.
-----------------------------------------------------------------------
void tiny_shell_loop(void) :
Εμφανίζει το prompt tiny-shell>>
και καλεί την συνάρτηση input_detection() για να εντοπίσει οποιαδήποτε είσοδο.
Τερματίζει για είσοδο exit ή Ctrl+D
-----------------------------------------------------------------------
int iput_detection(void) :
Διαβάζει stdin (μέχρι 1024 χαρακκτήρες)
Διαχωρίζει την είσοδο σε tokens με βάση τα κενά με την χρήση του strtok

Επιστρέφει:
1-> το shell συνεχίζει να λειτουργεί
0-> δόθηκε exit 
-1-> ανίχνευση EOF
-----------------------------------------------------------------------
int command_processing(char *argv[], int argc) :
ελέγχει αν η εντολή που δώθηκε είναι η exit ή help 
και μετά αν είναι μια από τις ls,exho,cat και την εκτελεί με την συνάρτηση execute_external_command
Σε κάθε άλλη περίπτωση τυπώνει μήνυμα "command not found"

Επιστρέφει:
1-> το shell συνεχίζει να λειτουργεί
0-> εντολή exit
-----------------------------------------------------------------------
int execute_external_command(char *argv[], int argc) :

Ορίσματα:
char *argv[] -> πίνακας ορισμάτων πχ {"ls","-l",NULL}
int argc -> αριθμός ορισμάτων

Εντοπίζει το εκτελέσιμο μέσω της find_path()
δημιουργεί νέα διεργασία με fork() και το παιδί εκτελέι την εντολή μέσω execve() (είναι σημαντικό το fork διότι το execve έχει ως αποτέλεσμα να τερματίζει το proccess επομένως αφού δεν θες να τερματίσει το πρόγραμμα πρέπει να τερματίσει το child και όχι ο parent)
Τέλος περιμένει με waitpid() και εμφανίζει τον κωδικό εξόδου 

Επιστρέφει:
1-> μετά την ολοκλήρωση της εντολής
Ή μηνύματα σφάλματος
-----------------------------------------------------------------------
char* find_in_path(const char *command):

Ορίσματα:
const char *command -> το όνομα της εντολής

Αν η εντολή περιέχει / ελέγχει αν είναι εκτελέσιμη με access()
αλλιώς ψάχνει κάθε κατάλογο στο PATH για να βρει το εκτελέσιμο
Επιστρέφει το πλήρες μονοπάτι του εκτελέσιμου ή NULL αν δεν βρεθεί

Επιστρέφει:
char* -> Συμβολοσειρά με το πλήρες path της εντολής, το οποίο πρέπει να ελευθερωθεί με free() μετά την χρήση της εντολής
NUll -> αν δεν βρει το path
-----------------------------------------------------------------------