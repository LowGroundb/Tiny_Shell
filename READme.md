# TinyShell
-----------------------------------------------------------------------
Ένα μικρό Unix shell γραμμένο σε C για Linux.

Το TinyShell, είναι ένα απλά Unix like shell σχεδιασμένο για να συμπεριφέρεται όπως ένα σύγχρονο command interpreter. Χρησιμοποιέι POSIX system calls (fork, execve,waitpid,access), για την κατανόηση του τρόπου λειτουργίας των Unix shells.


## Χαρακτηριστικά:
-----------------------------------------------------------------------
1. Εμφανίζει prompt (tiny-shell>>)
2. Αναλύει τα ορίσματα
3. Εντοπίζει εκτελέσιμα στο PATH
4. Τα εκτελέι με fork και execve
5. Αναφέρει τους κωδικούς εξόδου
6. Μπορεί να εκτελεί προγράμματα όπως ls, cat ή echo, και τερματίζει    ομαλά είτε με EOF είτε με την εντολή exit (για τώρα).
7.Μπορεί να εκτελέσει εντολές ανακτεύθυνσης εξόδου με τον τελεστή >,<
8.Υποστηρίζει τη σύνδεση δύο εντολών μέσω του αγωγού | χρησιμοποιόντας την συνάρτηση pipe()
9.Υποστιρίζει εντολές που συνδιάζουν εντολές αγωγού με εντολές ανακατεύθυνσης
10. Υποστηρίζει εκτέλεση εντολών στο παρασκήνιο (background) με το σύμβολο &
11. Υλοποιεί Job Control με τις εντολές fg, bg και jobs
12. Χειρισμός σημάτων (signals) για Ctrl-C και Ctrl-Z

## Προαπαιτούμενα:
-----------------------------------------------------------------------
1. Λειτουργικό σύστμα Linux για την χρήση των fork execve 
2. Compiler gcc ή clang
3. Εγκατεστημένα βασικά Unix εγαλεία (ls,cat,echo) αφού δεν έγινε η υλοποίση αυτών αλλά απλά καλούνται από το PATH

## Για Build: 
-----------------------------------------------------------------------

```bash
gcc -Wall -Wextra -o tinyshell tiny_shell.c
```

## Για Εκτέλεση
-----------------------------------------------------------------------

```bash
./tinyshell
```

## Περιγραφή Κώδικα:
-----------------------------------------------------------------------
### int main(void) : 
-----------------------------------------------------------------------
Η συνάρτηση εκκίνησης του προγράμματος:
 Εγκαθιστά τον SIGCHLD handler για να παρακολουθεί τις διεργασίες παρασκηνίου
 Θέτει το shell στο δικό του process group με setpgid(0, 0)
 Δίνει στο shell τον έλεγχο του τερματικού με tcsetpgrp()
 Καλεί την init_signal_handlers() για να αγνοήσει τα SIGINT και SIGTSTP
 Ξεκινά τον βρόχο εντολών με tiny_shell_loop()

### void tiny_shell_loop(void) :
-----------------------------------------------------------------------
Εμφανίζει το prompt tiny-shell>>
και καλεί την συνάρτηση input_detection() για να εντοπίσει οποιαδήποτε είσοδο.
Τερματίζει για:
 Είσοδο exit
 Ctrl+D (EOF)


### int iput_detection(void) :
-----------------------------------------------------------------------
Διαβάζει stdin (μέχρι 1024 χαρακκτήρες)
Διαχωρίζει την είσοδο σε tokens με βάση τα κενά με την χρήση του strtok

Επιστρέφει:
1-> το shell συνεχίζει να λειτουργεί
0-> δόθηκε exit 
-1-> ανίχνευση EOF

### int command_processing(char *argv[], int argc) :
-----------------------------------------------------------------------
Επεξεργάζεται την εισαγόμενη εντολή:

1. Ελέγχει για background execution:** Αν το τελευταίο όρισμα είναι `&`, το αφαιρεί και ορίζει το flag background = true

2. Ενσωματωμένες εντολές (built-ins):
   exit - Τερματίζει το shell
   help - Εμφανίζει διαθέσιμες εντολές
   jobs - Εμφανίζει λίστα με όλες τις ενεργές εργασίες (jobs)
   fg %N - Φέρνει την εργασία N στο προσκήνιο (foreground)
   bg %N - Συνεχίζει την εργασία N στο παρασκήνιο (background)

3. Ανίχνευση pipes: Καλεί την pipe_detection() για να εντοπίσει το σύμβολο |

4. Ανακατεύθυνση: Καλεί την parse_redirection() για να επεξεργαστεί <, >, >>

5. Εκτέλεση: Καλεί την execute_external_command()

Επιστρέφει:
 1 → το shell συνεχίζει να λειτουργεί
 0 → εντολή exit

### int execute_external_command(char *argv[], char *infile, char *outfile, int append, bool background):
-----------------------------------------------------------------------
Ορίσματα:

 char *argv[] - Πίνακας ορισμάτων πχ {"ls", "-l", NULL}
 char *infile - Αρχείο εισόδου (ή NULL)
 char *outfile - Αρχείο εξόδου (ή NULL)
 int append - Flag για append (1) ή truncate (0)
 bool background - Flag για background execution


Εντοπίζει το εκτελέσιμο μέσω της find_in_path()
Δημιουργεί νέα διεργασία με fork()
Στο παιδί:
    Τοποθετεί τον εαυτό του σε νέο process group με setpgid(0, 0)
    Επαναφέρει όλα τα signal handlers σε SIG_DFL
    Κάνει redirect input/output αν χρειάζεται
    Εκτελεί την εντολή με execve()
Στον γονέα:
    Τοποθετεί το παιδί στο δικό του process group με setpgid(pid, pid)
    Αν foreground:
      Δίνει έλεγχο τερματικού στο παιδί με tcsetpgrp()
      Περιμένει με waitpid() και flag WUNTRACED για να ανιχνεύσει Ctrl-Z
      Παίρνει πίσω τον έλεγχο του τερματικού
      Αν σταμάτησε (Ctrl-Z), προσθέτει στο job table ως STOPPED
    Αν background:
      Προσθέτει στο job table ως RUNNING
      Εκτυπώνει [job_id] pid
      Επιστρέφει αμέσως χωρίς να περιμένει

Επιστρέφει:
- 1 μετά την ολοκλήρωση
- Μηνύματα σφάλματος αν αποτύχει


## char* find_in_path(const char *command):
-----------------------------------------------------------------------
Ορίσματα:
const char *command -> το όνομα της εντολής

Αν η εντολή περιέχει / ελέγχει αν είναι εκτελέσιμη με access()
αλλιώς ψάχνει κάθε κατάλογο στο PATH για να βρει το εκτελέσιμο
Επιστρέφει το πλήρες μονοπάτι του εκτελέσιμου ή NULL αν δεν βρεθεί

Επιστρέφει:
char* -> Συμβολοσειρά με το πλήρες path της εντολής, το οποίο πρέπει να ελευθερωθεί με free() μετά την χρήση της εντολής
NUll -> αν δεν βρει το path

## int redirect(char *infile, char *outfile, int append)
-----------------------------------------------------------------------
Ορίσματα:
char *infile->είναι το όνομα του αρχείου από το οποίο θα διαβάσει
char *outfile->είναι το όνομα του αρχείου στο οποίο θα γράψουμε την έξοδο
int append-> παίρνει τιμές 0 αν το αρχείο θα το κάνει truncate δηλαδή θα σβήσει τα πάντα και θα γράφει από την αρχή. 1 αν αθ κάνει append δηλαδή να προσθέσει νέα δεδομένα στο τέλος του αρχείου.

Επιστρέφει:
1 αν όλα πάνε καλά
-1 αν έχω κάποιο error στην εντολή open()

## int parse_redirection(char *argv[], int *argc,char **infile, char **outfile, int *append)
-----------------------------------------------------------------------
Ορίσματα:
char *argv[]->πίνακας ορισμάτων πχ {"cat","<","input.txt",">","output.txt",NULL}
int *argc->αριθμός ορισμάτων
char **infile->δείκτης σε string όπου θα αποθηκευτεί το όνομα του αρχείου εισόδου
char **outfile->δείκτης σε string όπου θα αποθηκευτεί το όνομα του αρχείου εξόδου
int *append->flag για το αν η έξοδος θα γίνει append (1) ή truncate (0)

Σαρώνει το argv για <,>,>> Τα αφαιρεί κάνοντας τα NULL και ενημερώνει τα *infile,*outfile,*append

Επιστρέφει:
0 αν όλα πήγαν καλά
1 σε περίπτωση συντακτικού λάθους

## int command_count(char *argv[], int argc)
-----------------------------------------------------------------------
Ορίσματα:
char *argv[]->πίνακας ορισμάτων πχ {"cat","<","input.txt",">","output.txt",NULL}
int *argc->αριθμός ορισμάτων

Μετράει πόσες εντολές υπάρχουν στον πίνακα argv, ξέροντας πως οι εντολές διαχωρίζονται με NULL

Επιστρέφει:
Τον αριθμό των εντολών στον πίνακα argv

## int pipe_detection(char *argv[], int argc)
-----------------------------------------------------------------------
Ορίσματα:
char *argv[]->πίνακας ορισμάτων πχ {"cat","<","input.txt",">","output.txt",NULL}
int *argc->αριθμός ορισμάτων

Σαρώνει τον πίνακα για το σύμβολο |. Αν το βρει το αντικαθιστά με NULL για να ξεχωρίσει τον argv σε ξεχωριστά τμήματα στα οποία υπάρχουν οι εντολές. Τέλος καλεί την command_count για να υπολογίσει τον αριθμό των εντολών.

Επιστρέφει:
Τον αριθμό των εντολών που βρέθηκαν
-1 σε περίπτωση συντακτικού λάθους

## int piping(char *argv[], int pipe_count)
-----------------------------------------------------------------------
Ορίσμτα:
char *argv[]->πίνακας ορισμάτων πχ {"cat","<","input.txt",">","output.txt",NULL} όπου τα | έχουν αντικατασταθεί από NULL
int pipe_count-> αριθμός εντολών που θα εκτελεστούν

Δημιουργεί pipe_count-1 pipes για να συνδέσει την έξοδο κάθε εντολής με την είσοδο της επόμενης.
Κάνει fork() για κάθε εντολή, όπου κάθε παιδί συνέει τα stdin/stdout με τα κατάλληλα pipes.Μετά κλείνει όλα τα μη απαραίτητα File Descriptors και καλεί την parse_redirection για να κάνει redirect input/output αν υπάρχει. Τέλος εκτελεί την εντολή με execvp
Μετά ο parent κλείνει όλα τα pipe ends και περιμένει με waitpid() τα παιδιά.

Επιστρέφει:
0 αν όλα πήγαν καλά
-1 σε περίπτωση σφάλματος(pipe,fork ή execvp)

### Job Control Structures

-----------------------------------------------------------------------

#### typedef enum { RUNNING, STOPPED, DONE } job_state_t

Καταστάσεις εργασιών:
RUNNING - Η εργασία τρέχει (foreground ή background)
STOPPED - Η εργασία έχει σταματήσει (Ctrl-Z)
DONE - Η εργασία έχει ολοκληρωθεί

#### typedef struct { int job_id; pid_t pgid; job_state_t state; char command[256]; } job_t

Δομή που αποθηκεύει πληροφορίες για κάθε εργασία:
job_id - Μοναδικός αριθμός εργασίας (1, 2, 3, ...)
pgid - Process Group ID της εργασίας
state - Κατάσταση της εργασίας
command - Η εντολή που εκτελέστηκε

### int add_job(pid_t pgid, job_state_t state, const char *cmd)

-----------------------------------------------------------------------

Προσθέτει μια νέα εργασία στο job table.

Ορίσματα:
pid_t pgid - Process Group ID της εργασίας
job_state_t state - Αρχική κατάσταση (RUNNING ή STOPPED)
const char *cmd - Η εντολή που εκτελέστηκε

Επιστρέφει:
Το job_id της νέας εργασίας
1 αν το job table είναι γεμάτο

### job_t* find_job(int job_id)

-----------------------------------------------------------------------

Αναζητά μια εργασία από το job_id της.

Ορίσματα:
int job_id - Ο αριθμός της εργασίας

Επιστρέφει:
Δείκτη στη δομή job_t αν βρεθεί
NULL αν δεν βρεθεί ή αν η εργασία έχει κατάσταση DONE

### void remove_job(int job_id)

-----------------------------------------------------------------------

Αφαιρεί μια εργασία από το job table μετακινώντας τις υπόλοιπες εργασίες.

Ορίσματα:
int job_id - Ο αριθμός της εργασίας προς αφαίρεση

### void sigchld_handler(int sig)

-----------------------------------------------------------------------

Signal handler για SIGCHLD που καλείται όταν μια διεργασία-παιδί αλλάζει κατάσταση:

Λειτουργία:
1. Χρησιμοποιεί waitpid(-1, &status, WNOHANG | WUNTRACED | WCONTINUED) για να ελέγξει όλες τις διεργασίες-παιδιά χωρίς blocking
2. Ενημερώνει την κατάσταση της εργασίας:
   - Αν τερμάτισε (WIFEXITED ή WIFSIGNALED) → DONE και εκτυπώνει μήνυμα
   - Αν σταμάτησε (WIFSTOPPED) → STOPPED
   - Αν συνέχισε (WIFCONTINUED) → RUNNING
3. Αποθηκεύει και επαναφέρει το errno για ασφάλεια

### void init_signal_handlers(void)

-----------------------------------------------------------------------

Εγκαθιστά signal handlers για το shell:

Signals που αγνοούνται (SIG_IGN):
SIGINT (Ctrl-C) - Δεν τερματίζει το shell
SIGTSTP (Ctrl-Z) - Δεν σταματάει το shell
SIGTTIN - Αγνοείται για terminal input control
SIGTTOU - Αγνοείται για terminal output control

Αποτέλεσμα: Μόνο οι foreground processes λαμβάνουν αυτά τα signals, όχι το ίδιο το shell.